import {
  MDCCheckboxFoundation
} from "./chunk-L42KNFL3.js";
import "./chunk-NQKK4KOY.js";
import {
  dist_default
} from "./chunk-HP4L43Z3.js";
import "./chunk-XYV7FCGY.js";
import "./chunk-THJSFEX3.js";
import "./chunk-VL3N5LEO.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-C7L5FITX.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-2U2ZJOCG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  compute_rest_props,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_current_component,
  get_spread_update,
  init,
  insert_dev,
  is_function,
  listen_dev,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  space,
  svg_element,
  validate_slots
} from "./chunk-7JRVFVIN.js";
import "./chunk-Q6PQAFAF.js";

// node_modules/@smui/checkbox/dist/Checkbox.svelte
var file = "node_modules/@smui/checkbox/dist/Checkbox.svelte";
function create_fragment(ctx) {
  let div3;
  let input;
  let input_class_value;
  let input_value_value;
  let input_data_indeterminate_value;
  let useActions_action;
  let t0;
  let div1;
  let svg;
  let path;
  let t1;
  let div0;
  let t2;
  let div2;
  let div3_class_value;
  let div3_style_value;
  let useActions_action_1;
  let forwardEvents_action;
  let Ripple_action;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = classMap({
        [
          /*input$class*/
          ctx[9]
        ]: true,
        "mdc-checkbox__native-control": true
      })
    },
    { type: "checkbox" },
    /*inputProps*/
    ctx[20],
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    {
      __value: input_value_value = /*isUninitializedValue*/
      ctx[19](
        /*valueKey*/
        ctx[7]
      ) ? (
        /*value*/
        ctx[6]
      ) : (
        /*valueKey*/
        ctx[7]
      )
    },
    {
      "data-indeterminate": input_data_indeterminate_value = !/*isUninitializedValue*/
      ctx[19](
        /*indeterminate*/
        ctx[0]
      ) && /*indeterminate*/
      ctx[0] ? "true" : void 0
    },
    /*nativeControlAttrs*/
    ctx[16],
    prefixFilter(
      /*$$restProps*/
      ctx[26],
      "input$"
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let div3_levels = [
    {
      class: div3_class_value = classMap({
        [
          /*className*/
          ctx[3]
        ]: true,
        "mdc-checkbox": true,
        "mdc-checkbox--disabled": (
          /*disabled*/
          ctx[1]
        ),
        "mdc-checkbox--touch": (
          /*touch*/
          ctx[5]
        ),
        "mdc-data-table__header-row-checkbox": (
          /*context*/
          ctx[21] === "data-table" && /*dataTableHeader*/
          ctx[22]
        ),
        "mdc-data-table__row-checkbox": (
          /*context*/
          ctx[21] === "data-table" && !/*dataTableHeader*/
          ctx[22]
        ),
        .../*internalClasses*/
        ctx[14]
      })
    },
    {
      style: div3_style_value = Object.entries(
        /*internalStyles*/
        ctx[15]
      ).map(func).concat([
        /*style*/
        ctx[4]
      ]).join(" ")
    },
    exclude(
      /*$$restProps*/
      ctx[26],
      ["input$"]
    )
  ];
  let div_data_3 = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div_data_3 = assign(div_data_3, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      input = element("input");
      t0 = space();
      div1 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t1 = space();
      div0 = element("div");
      t2 = space();
      div2 = element("div");
      set_attributes(input, input_data);
      add_location(input, file, 30, 2, 804);
      attr_dev(path, "class", "mdc-checkbox__checkmark-path");
      attr_dev(path, "fill", "none");
      attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
      add_location(path, file, 52, 6, 1442);
      attr_dev(svg, "class", "mdc-checkbox__checkmark");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 51, 4, 1378);
      attr_dev(div0, "class", "mdc-checkbox__mixedmark");
      add_location(div0, file, 58, 4, 1582);
      attr_dev(div1, "class", "mdc-checkbox__background");
      add_location(div1, file, 50, 2, 1335);
      attr_dev(div2, "class", "mdc-checkbox__ripple");
      add_location(div2, file, 60, 2, 1633);
      set_attributes(div3, div_data_3);
      add_location(div3, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, input);
      if (input.autofocus)
        input.focus();
      ctx[36](input);
      input.checked = /*nativeChecked*/
      ctx[12];
      append_dev(div3, t0);
      append_dev(div3, div1);
      append_dev(div1, svg);
      append_dev(svg, path);
      append_dev(div1, t1);
      append_dev(div1, div0);
      append_dev(div3, t2);
      append_dev(div3, div2);
      ctx[38](div3);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*input$use*/
            ctx[8]
          )),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[37]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            div3,
            /*use*/
            ctx[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[18].call(null, div3)),
          action_destroyer(Ripple_action = dist_default.call(null, div3, {
            unbounded: true,
            addClass: (
              /*addClass*/
              ctx[23]
            ),
            removeClass: (
              /*removeClass*/
              ctx[24]
            ),
            addStyle: (
              /*addStyle*/
              ctx[25]
            ),
            active: (
              /*rippleActive*/
              ctx[17]
            ),
            eventTarget: (
              /*checkbox*/
              ctx[11]
            )
          })),
          listen_dev(
            div3,
            "animationend",
            /*animationend_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*input$class*/
        512 && input_class_value !== (input_class_value = classMap({
          [
            /*input$class*/
            ctx2[9]
          ]: true,
          "mdc-checkbox__native-control": true
        })) && { class: input_class_value },
        { type: "checkbox" },
        /*inputProps*/
        ctx2[20],
        dirty[0] & /*disabled*/
        2 && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        dirty[0] & /*valueKey, value*/
        192 && input_value_value !== (input_value_value = /*isUninitializedValue*/
        ctx2[19](
          /*valueKey*/
          ctx2[7]
        ) ? (
          /*value*/
          ctx2[6]
        ) : (
          /*valueKey*/
          ctx2[7]
        )) && { __value: input_value_value },
        dirty[0] & /*indeterminate*/
        1 && input_data_indeterminate_value !== (input_data_indeterminate_value = !/*isUninitializedValue*/
        ctx2[19](
          /*indeterminate*/
          ctx2[0]
        ) && /*indeterminate*/
        ctx2[0] ? "true" : void 0) && {
          "data-indeterminate": input_data_indeterminate_value
        },
        dirty[0] & /*nativeControlAttrs*/
        65536 && /*nativeControlAttrs*/
        ctx2[16],
        dirty[0] & /*$$restProps*/
        67108864 && prefixFilter(
          /*$$restProps*/
          ctx2[26],
          "input$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*input$use*/
      256)
        useActions_action.update.call(
          null,
          /*input$use*/
          ctx2[8]
        );
      if (dirty[0] & /*nativeChecked*/
      4096) {
        input.checked = /*nativeChecked*/
        ctx2[12];
      }
      set_attributes(div3, div_data_3 = get_spread_update(div3_levels, [
        dirty[0] & /*className, disabled, touch, internalClasses*/
        16426 && div3_class_value !== (div3_class_value = classMap({
          [
            /*className*/
            ctx2[3]
          ]: true,
          "mdc-checkbox": true,
          "mdc-checkbox--disabled": (
            /*disabled*/
            ctx2[1]
          ),
          "mdc-checkbox--touch": (
            /*touch*/
            ctx2[5]
          ),
          "mdc-data-table__header-row-checkbox": (
            /*context*/
            ctx2[21] === "data-table" && /*dataTableHeader*/
            ctx2[22]
          ),
          "mdc-data-table__row-checkbox": (
            /*context*/
            ctx2[21] === "data-table" && !/*dataTableHeader*/
            ctx2[22]
          ),
          .../*internalClasses*/
          ctx2[14]
        })) && { class: div3_class_value },
        dirty[0] & /*internalStyles, style*/
        32784 && div3_style_value !== (div3_style_value = Object.entries(
          /*internalStyles*/
          ctx2[15]
        ).map(func).concat([
          /*style*/
          ctx2[4]
        ]).join(" ")) && { style: div3_style_value },
        dirty[0] & /*$$restProps*/
        67108864 && exclude(
          /*$$restProps*/
          ctx2[26],
          ["input$"]
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*use*/
      4)
        useActions_action_1.update.call(
          null,
          /*use*/
          ctx2[2]
        );
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & /*rippleActive, checkbox*/
      133120)
        Ripple_action.update.call(null, {
          unbounded: true,
          addClass: (
            /*addClass*/
            ctx2[23]
          ),
          removeClass: (
            /*removeClass*/
            ctx2[24]
          ),
          addStyle: (
            /*addStyle*/
            ctx2[25]
          ),
          active: (
            /*rippleActive*/
            ctx2[17]
          ),
          eventTarget: (
            /*checkbox*/
            ctx2[11]
          )
        });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      ctx[36](null);
      ctx[38](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "disabled",
    "touch",
    "indeterminate",
    "group",
    "checked",
    "value",
    "valueKey",
    "input$use",
    "input$class",
    "getId",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, []);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { disabled = false } = $$props;
  let { touch = false } = $$props;
  let { indeterminate = uninitializedValue } = $$props;
  let { group = uninitializedValue } = $$props;
  let { checked = uninitializedValue } = $$props;
  let { value = null } = $$props;
  let { valueKey = uninitializedValue } = $$props;
  let { input$use = [] } = $$props;
  let { input$class = "" } = $$props;
  let element2;
  let instance;
  let checkbox;
  let internalClasses = {};
  let internalStyles = {};
  let nativeControlAttrs = {};
  let rippleActive = false;
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let nativeChecked = isUninitializedValue(group) ? isUninitializedValue(checked) ? false : checked !== null && checked !== void 0 ? checked : void 0 : group.indexOf(value) !== -1;
  let context = getContext("SMUI:checkbox:context");
  let dataTableHeader = getContext("SMUI:data-table:row:header");
  let previousChecked = checked;
  let previousGroup = isUninitializedValue(group) ? [] : [...group];
  let previousNativeChecked = nativeChecked;
  onMount(() => {
    $$invalidate(11, checkbox.indeterminate = !isUninitializedValue(indeterminate) && indeterminate, checkbox);
    $$invalidate(10, instance = new MDCCheckboxFoundation({
      addClass,
      forceLayout: () => element2.offsetWidth,
      hasNativeControl: () => true,
      isAttachedToDOM: () => Boolean(element2.parentNode),
      isChecked: () => nativeChecked !== null && nativeChecked !== void 0 ? nativeChecked : false,
      isIndeterminate: () => isUninitializedValue(indeterminate) ? false : indeterminate,
      removeClass,
      removeNativeControlAttr,
      setNativeControlAttr: addNativeControlAttr,
      setNativeControlDisabled: (value2) => $$invalidate(1, disabled = value2)
    }));
    const accessor = {
      _smui_checkbox_accessor: true,
      get element() {
        return getElement();
      },
      get checked() {
        return nativeChecked !== null && nativeChecked !== void 0 ? nativeChecked : false;
      },
      set checked(value2) {
        if (nativeChecked !== value2) {
          $$invalidate(12, nativeChecked = value2);
        }
      },
      get indeterminate() {
        return isUninitializedValue(indeterminate) ? false : indeterminate;
      },
      set indeterminate(value2) {
        $$invalidate(0, indeterminate = value2);
      },
      activateRipple() {
        if (!disabled) {
          $$invalidate(17, rippleActive = true);
        }
      },
      deactivateRipple() {
        $$invalidate(17, rippleActive = false);
      }
    };
    dispatch(element2, "SMUIGenericInput:mount", accessor);
    dispatch(element2, "SMUICheckbox:mount", accessor);
    instance.init();
    return () => {
      dispatch(element2, "SMUIGenericInput:unmount", accessor);
      dispatch(element2, "SMUICheckbox:unmount", accessor);
      instance.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(14, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(14, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value2) {
    if (internalStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete internalStyles[name];
        $$invalidate(15, internalStyles);
      } else {
        $$invalidate(15, internalStyles[name] = value2, internalStyles);
      }
    }
  }
  function addNativeControlAttr(name, value2) {
    if (nativeControlAttrs[name] !== value2) {
      $$invalidate(16, nativeControlAttrs[name] = value2, nativeControlAttrs);
    }
  }
  function removeNativeControlAttr(name) {
    if (!(name in nativeControlAttrs) || nativeControlAttrs[name] != null) {
      $$invalidate(16, nativeControlAttrs[name] = void 0, nativeControlAttrs);
    }
  }
  function getId() {
    return inputProps && inputProps.id;
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      checkbox = $$value;
      $$invalidate(11, checkbox), $$invalidate(27, group), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(0, indeterminate), $$invalidate(10, instance);
    });
  }
  function input_change_handler() {
    nativeChecked = this.checked;
    $$invalidate(12, nativeChecked), $$invalidate(27, group), $$invalidate(33, previousNativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(0, indeterminate), $$invalidate(11, checkbox), $$invalidate(10, instance);
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(13, element2);
    });
  }
  const animationend_handler = () => instance && instance.handleAnimationEnd();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("touch" in $$new_props)
      $$invalidate(5, touch = $$new_props.touch);
    if ("indeterminate" in $$new_props)
      $$invalidate(0, indeterminate = $$new_props.indeterminate);
    if ("group" in $$new_props)
      $$invalidate(27, group = $$new_props.group);
    if ("checked" in $$new_props)
      $$invalidate(28, checked = $$new_props.checked);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("valueKey" in $$new_props)
      $$invalidate(7, valueKey = $$new_props.valueKey);
    if ("input$use" in $$new_props)
      $$invalidate(8, input$use = $$new_props.input$use);
    if ("input$class" in $$new_props)
      $$invalidate(9, input$class = $$new_props.input$class);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCCheckboxFoundation,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    disabled,
    touch,
    indeterminate,
    group,
    checked,
    value,
    valueKey,
    input$use,
    input$class,
    element: element2,
    instance,
    checkbox,
    internalClasses,
    internalStyles,
    nativeControlAttrs,
    rippleActive,
    inputProps,
    nativeChecked,
    context,
    dataTableHeader,
    previousChecked,
    previousGroup,
    previousNativeChecked,
    addClass,
    removeClass,
    addStyle,
    addNativeControlAttr,
    removeNativeControlAttr,
    getId,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("touch" in $$props)
      $$invalidate(5, touch = $$new_props.touch);
    if ("indeterminate" in $$props)
      $$invalidate(0, indeterminate = $$new_props.indeterminate);
    if ("group" in $$props)
      $$invalidate(27, group = $$new_props.group);
    if ("checked" in $$props)
      $$invalidate(28, checked = $$new_props.checked);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("valueKey" in $$props)
      $$invalidate(7, valueKey = $$new_props.valueKey);
    if ("input$use" in $$props)
      $$invalidate(8, input$use = $$new_props.input$use);
    if ("input$class" in $$props)
      $$invalidate(9, input$class = $$new_props.input$class);
    if ("element" in $$props)
      $$invalidate(13, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(10, instance = $$new_props.instance);
    if ("checkbox" in $$props)
      $$invalidate(11, checkbox = $$new_props.checkbox);
    if ("internalClasses" in $$props)
      $$invalidate(14, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(15, internalStyles = $$new_props.internalStyles);
    if ("nativeControlAttrs" in $$props)
      $$invalidate(16, nativeControlAttrs = $$new_props.nativeControlAttrs);
    if ("rippleActive" in $$props)
      $$invalidate(17, rippleActive = $$new_props.rippleActive);
    if ("inputProps" in $$props)
      $$invalidate(20, inputProps = $$new_props.inputProps);
    if ("nativeChecked" in $$props)
      $$invalidate(12, nativeChecked = $$new_props.nativeChecked);
    if ("context" in $$props)
      $$invalidate(21, context = $$new_props.context);
    if ("dataTableHeader" in $$props)
      $$invalidate(22, dataTableHeader = $$new_props.dataTableHeader);
    if ("previousChecked" in $$props)
      $$invalidate(31, previousChecked = $$new_props.previousChecked);
    if ("previousGroup" in $$props)
      $$invalidate(32, previousGroup = $$new_props.previousGroup);
    if ("previousNativeChecked" in $$props)
      $$invalidate(33, previousNativeChecked = $$new_props.previousNativeChecked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*group, nativeChecked, value, checked, indeterminate, checkbox, instance*/
    402660417 | $$self.$$.dirty[1] & /*previousNativeChecked, previousGroup, previousChecked*/
    7) {
      $: {
        let callHandleChange = false;
        if (!isUninitializedValue(group)) {
          if (previousNativeChecked !== nativeChecked) {
            const idx = group.indexOf(value);
            if (nativeChecked && idx === -1) {
              group.push(value);
              $$invalidate(27, group), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(0, indeterminate), $$invalidate(11, checkbox), $$invalidate(10, instance);
            } else if (!nativeChecked && idx !== -1) {
              group.splice(idx, 1);
              $$invalidate(27, group), $$invalidate(33, previousNativeChecked), $$invalidate(12, nativeChecked), $$invalidate(6, value), $$invalidate(32, previousGroup), $$invalidate(28, checked), $$invalidate(31, previousChecked), $$invalidate(0, indeterminate), $$invalidate(11, checkbox), $$invalidate(10, instance);
            }
            callHandleChange = true;
          } else {
            const idxPrev = previousGroup.indexOf(value);
            const idx = group.indexOf(value);
            if (idxPrev > -1 && idx === -1) {
              $$invalidate(12, nativeChecked = false);
              callHandleChange = true;
            } else if (idx > -1 && idxPrev === -1) {
              $$invalidate(12, nativeChecked = true);
              callHandleChange = true;
            }
          }
        }
        if (isUninitializedValue(checked)) {
          if (!!previousNativeChecked !== !!nativeChecked) {
            callHandleChange = true;
          }
        } else if (checked !== (nativeChecked !== null && nativeChecked !== void 0 ? nativeChecked : null)) {
          if (checked === previousChecked) {
            $$invalidate(28, checked = nativeChecked !== null && nativeChecked !== void 0 ? nativeChecked : null);
            if (!isUninitializedValue(indeterminate)) {
              $$invalidate(0, indeterminate = false);
            }
          } else {
            $$invalidate(12, nativeChecked = checked !== null && checked !== void 0 ? checked : void 0);
          }
          callHandleChange = true;
        }
        if (checkbox) {
          if (isUninitializedValue(indeterminate)) {
            if (checkbox.indeterminate) {
              $$invalidate(11, checkbox.indeterminate = false, checkbox);
              callHandleChange = true;
            }
          } else {
            if (!indeterminate && checkbox.indeterminate) {
              $$invalidate(11, checkbox.indeterminate = false, checkbox);
              callHandleChange = true;
            } else if (indeterminate && !checkbox.indeterminate) {
              $$invalidate(11, checkbox.indeterminate = true, checkbox);
              callHandleChange = true;
            }
          }
        }
        $$invalidate(31, previousChecked = checked);
        $$invalidate(32, previousGroup = isUninitializedValue(group) ? [] : [...group]);
        $$invalidate(33, previousNativeChecked = nativeChecked);
        if (callHandleChange && instance) {
          instance.handleChange();
        }
      }
    }
  };
  return [
    indeterminate,
    disabled,
    use,
    className,
    style,
    touch,
    value,
    valueKey,
    input$use,
    input$class,
    instance,
    checkbox,
    nativeChecked,
    element2,
    internalClasses,
    internalStyles,
    nativeControlAttrs,
    rippleActive,
    forwardEvents,
    isUninitializedValue,
    inputProps,
    context,
    dataTableHeader,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    group,
    checked,
    getId,
    getElement,
    previousChecked,
    previousGroup,
    previousNativeChecked,
    blur_handler,
    focus_handler,
    input_binding,
    input_change_handler,
    div3_binding,
    animationend_handler
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        style: 4,
        disabled: 1,
        touch: 5,
        indeterminate: 0,
        group: 27,
        checked: 28,
        value: 6,
        valueKey: 7,
        input$use: 8,
        input$class: 9,
        getId: 29,
        getElement: 30
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touch() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touch(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueKey() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueKey(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input$use() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input$use(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input$class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input$class(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getId() {
    return this.$$.ctx[29];
  }
  set getId(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[30];
  }
  set getElement(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/@smui/checkbox/dist/index.js
var dist_default2 = Checkbox_default;
export {
  dist_default2 as default
};
/*! Bundled license information:

@material/checkbox/adapter.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/checkbox/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_checkbox.js.map
